
MySquirrel : Protect PHP and MySQL against injection attacks!
=============================================================

MySquirrel is a lightweight object-oriented wrapper around PHP's popular MySQL
and MySQLi extensions. The focus is on simplicity and ease of use, robust error
handling, and most of all, security.

Good old mysql_* functions are among the most commonly used in web development,
but they are rather difficult to protect against SQL injection attacks.
Injection-proofing often involves tedious escaping, and PHP supplies no less
than three functions with convoluted names for this purpose. However, a single
parameter left unescaped by accident is all it takes for a remote attacker to
pwn your entire database: e.g. "' OR 1 = 1; DELETE FROM table; -- whatever."

More modern extensions, such as MySQLi, allow for prepared statements and/or
parameterized queries that can greatly reduce injection vulnerabilities.
However, they are not always available with shared hosting where PHP programs
are most often deployed, not to mention that the powerful API makes common
tasks much more complicated than with mysql_* functions. It is just as tedious,
if not more, to use MySQLi properly as it is to use MySQL properly. As a result,
PHP developers often hang on to the nearly deprecated mysql_* functions.

MySquirrel simulates parameterized queries, by disallowing multiple-statement
queries by default, and by automatically escaping arguments. All you need to
do is to pass potentially unsafe values as additional parameters to query().
This is many times more convenient than escaping each of them manually, and
absolutely fabulous compared to MySQLi's tedious process of binding variables.

MySquirrel also allows you to use prepared statements with ease, even where
outdated mysql_* functions are all that you have. Unlike parameterized queries,
prepared statements are not merely simulated by the client but actually run on
the server-side. By using prepared statements, you can get extra security and
also gain performance when inserting a large number of records.

Other features include easy transaction control (only on InnoDB) and error
handling. Where MySQL(i) functions lack proper error handling, MySquirrel adds
PDO-style exceptions to aid debugging and to enforce good coding style.

MySquirrel, however, does not magically make your application secure. Improper
use would leave your site just as vulnerable to attacks as if you didn't use
MySquirrel at all. However, with proper use, it should be nearly impossible for
a remote attacker to pull off a successful SQL injection. Another advantage of
MySquirrel is that this "proper use" is easier to accomplish and consequently
less error-prone than with the usual soup of mysql_* functions.

MySquirrel is released under the GNU General Public License (GPL), version 3.
See the enclosed LICENSE file for the full terms and conditions.


Quick Start Guide
=================

    include('mysquirrel.php');
    
    $mysql = MySquirrel::connect('localhost', 'user', 'pass', 'database');
    $mysql->paranoid();
    
    $result = $mysql->query('SELECT * FROM users WHERE id = ?', $id);
    while ($row = $result->fetch()) {
        echo $row['name'];
    }

    $mysql->query('UPDATE users SET email = ? WHERE id = ?', $new_email, $id);

    $mysql->query('INSERT INTO users (name, password, email) VALUES (?, ?, ?)',
        $name, $password, $email);
    $id = $mysql->lastInsertID();
    
    $stmt = $mysql->prepare('INSERT INTO users VALUES (null, ?, ?, ?)');
    $stmt->execute($name, $password, $email);
    $stmt->execute($name, $password, $email);
    $stmt->execute($name, $password, $email);
    

Explanation of the Above
========================
  
    MySquirrel::connect() returns an object. You call methods on this object
    to interact with the MySQL connection. For example, instead of calling
    mysql_query() or MySQLi::query(), you would call $mysql->query().
    
    MySquirrel caches database connections. If you lose reference to the object
    you were working with (e.g. you move to a different scope), just call
    MySquirrel::connect() again with the same parameters to retrieve it.
    
    If the MySQLi extension is available, MySquirrel will use it instead of the
    old mysql_* functions. But this choice is transparent to the user, and does
    cause any changes to the way you work with MySquirrel. If MySQLi is not
    available, MySquirrel falls back on mysql_* functions, again transparently.
    
    Never, ever put variables into the querystring, e.g. "WHERE id = $id".
    Script kiddies and other criminals love you for mixing variables with SQL!
    Instead, put a question mark (?) where you would normally put a variable.
    Then supply the variable itself as an additional argument when you call
    query(), as in the examples above. You can supply as many variables as you
    want in this way, but the number of additional arguments must match the
    number of placeholders in the querystring. MySquirrel will automatically
    escape all parameters supplied using this syntax.
    
    Notice that query() will not accept querystrings that contain multiple
    SQL statements. Only one statement is permitted per method call. This helps
    prevent malicious folks from attaching "DELETE ... " or similar to your
    querystring. If you need to execute several statements at the same time,
    use rawQuery() instead, which however is a dangerous thing to do unless
    you are absolutely sure what you're doing.
    
    Paranoid mode, which can be activated by calling paranoid(), makes two
    changes to MySquirrel's behavior. First, it disables rawQuery(). Second, it
    makes query() refuse to execute any query with quotes or comments in it.
    This will also prevent you from using string literals in your querystrings,
    such as "SELECT * FROM tickets WHERE status = 'pending' ... " among others.
    Although string literals are not necessarily insecure, in practice, a lot
    of these originate from untrusted sources and result in vulnerabilities.
    Likewise, comments in short queries are a common sign of injection attacks.
    
    If your query has a result set (e.g. "SELECT", "SHOW", "DESCRIBE", etc.)
    then query() will return an instance of MySquirrelResult. You can fetch
    rows and other information about the result set by calling methods such as
    fetch(), fetchAll(), and numRows() on this object. See below for more.
    
    Prepared queries are executed in two steps. First, you call prepare() to
    create a prepared statement on the server (requires MySQL 4.1 or higher).
    Then, you call execute() on the returned object as many times as you want.
    This improves performance when running the same query over and over again.
    
    Unlike mysql_* functions, MySquirrel will not allow errors to pass silently.
    Nor will it follow the dickheaded practice of just die()'ing on any error.
    If any error occurs, an instance of MySquirrelException will be thrown.
    It is your responsibility to catch and handle this exception properly.
    Often, mysql_* doesn't even warn you when you try to execute SQL statements
    with syntax erorrs! This recklessness must come to an end, and MySquirrel
    goes to great lengths to remedy the situation where possible.


MySquirrel (Static)
===================

    connect($host, $user, $pass, $database, [$charset] )


MySquirrelDriver
================
    
    paranoid()
    prepare($querystring)
    query($querystring, [$param1, $param2 ... ] )
    rawQuery($querystring)
    affectedRows()
    lastInsertID()
    beginTransactiion()             // Only with InnoDB.
    commit()                        // Only with InnoDB.
    rollback()                      // Only with InnoDB.


MySquirrelPreparedStmt
======================

    execute( [$param1, $param2 ... ] )


MySquirrelResult
================
    
    fetch()                         // Returns both types of arrays.
    fetchAssoc()                    // Returns an associative array.
    fetchObject($class, $params)    // Returns an object.
    fetchRow()                      // Returns an enumerated array.
    fetchAll()                      // Returns every row in the result set.
    fieldInfo($offset)
    numFields()
    numRows()
